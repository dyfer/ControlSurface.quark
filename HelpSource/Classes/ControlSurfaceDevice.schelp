TITLE:: ControlSurfaceDevice
summary:: Interface with physical control surfaces
categories:: External Control > MIDI, Control Surface
related:: Classes/CSButton, Classes/CSSlider, Classes/CSKnob, Classes/CSEncoder, Classes/CSSimpleButton, Classes/CSMultistateButton, Classes/CSToggle, Classes/XTouchLCD, Classes/XTouch7segment

DESCRIPTION::

The strong::ControlSurface:: Quark provides an interface to communicate with MIDI control surfaces that feature buttons, knobs, sliders, displays, etc.

The basic building block of such interface is one of the subclasses of code::ControlSurfaceComponent::, like link::Classes/CSButton::, link::Classes/CSSlider::, link::Classes/XTouchLCD:: etc. allowing to communicate with a given emphasis::component::.
While these classes can be used individually, it is convenient to group them into a emphasis::device:: allowing access to all controls from one place.

code::ControlSurfaceDevice:: acts as a container for code::ControlSurfaceComponent::s, allowing storing and recalling configuration for the whole device, setting MIDI ports, as well as accessing components by an code::id::.


CLASSMETHODS::

METHOD:: new
Create new instance

ARGUMENT:: midiOut
A code::MIDIOut:: or code::MIDIEndPoint::. Can also be set later.

ARGUMENT:: midiIn
A code::MIDIEndPoint::. Can also be set later.

ARGUMENT:: initMIDI
If code::true::, MIDI client will be initialized and all inputs will be connected.

returns:: a code::ControlSurfaceDevice::


METHOD:: loadPreset
Load configuration for a given device from a preset, stored inside this quark.

ARGUMENT:: name
name of the preset (see link::#*listPresets::)

ARGUMENT:: initMIDI
If code::true::, MIDI client will be initialized and all inputs will be connected.

returns:: a new instance of code::ControlSurfaceDevice::, configured for use with a chosen device

METHOD:: load
Load configuration for a given device from file. See link::#*loadPreset::

ARGUMENT:: path
full path to a file

ARGUMENT:: initMIDI
If code::true::, MIDI client will be initialized and all inputs will be connected.

returns:: a new instance of code::ControlSurfaceDevice::, configured for use with a chosen device


METHOD:: listPresets
List all presets included with this Quark.

returns:: An array of names


METHOD:: throwErrorOnDoesNotUnderstand
When code::true:: (default), not recognized method will cause throwing an error. When code::false::, only warning will be posted.

Components added to this code::ControlSurfaceDevice:: can be given an code::id::, which makes them accessible under pseudo-methods. This parameter defines behavior for when a method is not recognized neither as a instance method, nor pseudo-method pointing to a component.


private:: presetsExtension

private:: initClass

private:: presetsPath



INSTANCEMETHODS::

METHOD:: components
The main method to add components to the instance of the class. See examples below.

ARGUMENT:: componentCollection
This can be any collection up to 3 levels deep. A dictionary of arrays or dictionary of dictionaries are reasonable choices.


METHOD:: free
Free all resources.

code::.free:: is called on all of the components.


private:: initAfterLoad

private:: updateAllMidiOut

private:: update

private:: updateAllResponders

METHOD:: save
Save current component configuration to a file

ARGUMENT:: path
full path to a file

ARGUMENT:: overwrite
If the file exists and this is code::true::, it will be overwritten.


private:: tryInitMidi

private:: prUpdateComponents

METHOD:: allowOverwritingIDs
When a component is given an ID, this class adds a pseudo-method allowing direct access to this component. In case there are duplicated IDs and this is code::true::, the new ones will overwrite the old ones under this id/method name.


private:: init

private:: initMIDI



private:: doesNotUnderstand


private:: collectIDs

private:: componentArray

private:: idDict

METHOD:: deviceInfo

returns:: A dictionary that can be populated with information about the device. Stored with a configuration/preset.

METHOD:: presetName
Get/set a preset name (for saving)

METHOD:: savePreset
Save current component configuration to a preset file. For development purposes only.
note::This will save the configuration inside the Quark folder structure and will interfere with updating the quark, or may be lost if the quark is re-downloaded.::

ARGUMENT:: name
Name to save the preset under. If nil, link::#-presetName:: will be used

ARGUMENT:: overwrite
Overwrite if exists




METHOD:: midiIn

ARGUMENT:: val
A code::MIDIEndPoint::. Will set all components.

returns:: an instance of code::MIDIEndPoint::, if set

METHOD:: inEndPoint

returns:: an instance of input code::MIDIEndPoint::, if set

METHOD:: midiOut
ARGUMENT:: val
A code::MIDIOut:: or code::MIDIEndPoint::. Will set all components.

returns:: an instance of code::MIDIOut::, if set

METHOD:: outEndPoint
returns:: an instance of output code::MIDIEndPoint::, if set




private:: addToAllAsDependant
private:: updateAllMidiIn

private:: updateAllMidi



EXAMPLES::

code::
//load from a preset
d = CSDevice.loadPreset("XTouchOne_noteRelative");

//midi should be set up automatically, but if not
d.midiIn_(MIDIIn.findPort("X-Touch One", ""));
d.midiOut_(MIDIOut.newByName("X-Touch One", ""));

//inspect components
d.components;
d.components.keys;

//access componenets
d.components[\encoderRight].action_({|val| "Encoder ".post; val.value.postln});

d.components[\slider][0].action_({|val| "slider ".post; val.value.postln});
d.components[\slider][0].value_(1.0.rand);

//set and id
d.components[\lcd].id = \lcd
d.lcd.string_(22.0.rand);
d.lcd.background_(Color.rand);
d.lcd.id = nil; //unset

//free;
d.free;


//alternatively, set up manually
d = CSDevice();

d.midiIn_(MIDIIn.findPort("X-Touch One", ""));
d.midiOut_(MIDIOut.newByName("X-Touch One", ""));//.latency_(0));
d.deviceInfo[\manufacturer] = "Behringer";
d.deviceInfo[\model] = "XTouch One";
d.deviceInfo[\version] = "1.04";
d.deviceInfo[\description] = "Set up for note-relative mode; slider and top encoder also have push-buttons";
d.presetName_("XTouchOne_noteRelative");

(
d.components_(
	(
		\buttons0: 6.collect({|inc| CSButton(1 + inc, 0, \note, nil, true, true)}),
		\buttons1: 6.collect({|inc| CSButton(7 + inc, 0, \note, nil, true, true)}),
		\buttons2: 7.collect({|inc| CSButton(13 + inc, 0, \note, nil, true, true)}),
		\buttonsTransport: 6.collect({|inc| CSButton(20 + inc, 0, \note, nil, true, true)}),
		\buttonsBank: 2.collect({|inc| CSButton(25 + inc, 0, \note, nil, true, true)}),
		\buttonsChannel: 2.collect({|inc| CSButton(27 + inc, 0, \note, nil, true, true)}),
		\buttonScrub: CSButton(29, 0, \note, nil, true, true),
		\buttonsBotton: ().putPairs([\top, \left, \center, \right, \bottom].collect({|name, inc| [name, CSButton(30 + inc, 0, \note, nil, true, true)]}).flat),
		\slider: [CSSlider(70, 0, nil, true, false), CSButton(110, 0, \note, nil, false, false)],
		\encoderTop: [CSEncoder(80, 0, nil, true, true, 64), CSButton(0, 0, \note, nil, false, false)],
		\encoderRight: CSEncoder(88, 0, nil, true, true, 64),
		\lcd: XTouchLCD(nil, 0x41),
		\led7seg: XTouch7seg(nil, 0x41)
	)
)
)

//for development - save as a preset
d.savePreset("XTouchOne2_noteRelative");

d.free;

::
